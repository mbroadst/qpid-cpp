// Auto-generated file, built from build/gen/protocol_defs.h src/utils.h src/error.h src/exceptions.h src/types.h src/datum.h src/json.h src/net.h src/cursor.h src/term.h
#pragma once
// Auto-generated by reql/gen.py
namespace RethinkDB { namespace Protocol {
namespace VersionDummy {
    enum class Version {
        V0_1 = 0x3f61ba36,
        V0_2 = 0x723081e1,
        V0_3 = 0x5f75e83e,
        V0_4 = 0x400c2d20,
        V1_0 = 0x34c2bdc3,
    };
    enum class Protocol {
        PROTOBUF = 0x271ffc41,
        JSON = 0x7e6970c7,
    };
}
namespace Query {
    enum class QueryType {
        START = 1,
        CONTINUE = 2,
        STOP = 3,
        NOREPLY_WAIT = 4,
        SERVER_INFO = 5,
    };
    namespace AssocPair {
    }
}
namespace Frame {
    enum class FrameType {
        POS = 1,
        OPT = 2,
    };
}
namespace Backtrace {
}
namespace Response {
    enum class ResponseType {
        SUCCESS_ATOM = 1,
        SUCCESS_SEQUENCE = 2,
        SUCCESS_PARTIAL = 3,
        WAIT_COMPLETE = 4,
        SERVER_INFO = 5,
        CLIENT_ERROR = 16,
        COMPILE_ERROR = 17,
        RUNTIME_ERROR = 18,
    };
    enum class ErrorType {
        INTERNAL = 1000000,
        RESOURCE_LIMIT = 2000000,
        QUERY_LOGIC = 3000000,
        NON_EXISTENCE = 3100000,
        OP_FAILED = 4100000,
        OP_INDETERMINATE = 4200000,
        USER = 5000000,
        PERMISSION_ERROR = 6000000,
    };
    enum class ResponseNote {
        SEQUENCE_FEED = 1,
        ATOM_FEED = 2,
        ORDER_BY_LIMIT_FEED = 3,
        UNIONED_FEED = 4,
        INCLUDES_STATES = 5,
    };
}
namespace Datum {
    enum class DatumType {
        R_NULL = 1,
        R_BOOL = 2,
        R_NUM = 3,
        R_STR = 4,
        R_ARRAY = 5,
        R_OBJECT = 6,
        R_JSON = 7,
    };
    namespace AssocPair {
    }
}
namespace Term {
    enum class TermType {
        DATUM = 1,
        MAKE_ARRAY = 2,
        MAKE_OBJ = 3,
        VAR = 10,
        JAVASCRIPT = 11,
        UUID = 169,
        HTTP = 153,
        ERROR = 12,
        IMPLICIT_VAR = 13,
        DB = 14,
        TABLE = 15,
        GET = 16,
        GET_ALL = 78,
        EQ = 17,
        NE = 18,
        LT = 19,
        LE = 20,
        GT = 21,
        GE = 22,
        NOT = 23,
        ADD = 24,
        SUB = 25,
        MUL = 26,
        DIV = 27,
        MOD = 28,
        FLOOR = 183,
        CEIL = 184,
        ROUND = 185,
        APPEND = 29,
        PREPEND = 80,
        DIFFERENCE = 95,
        SET_INSERT = 88,
        SET_INTERSECTION = 89,
        SET_UNION = 90,
        SET_DIFFERENCE = 91,
        SLICE = 30,
        SKIP = 70,
        LIMIT = 71,
        OFFSETS_OF = 87,
        CONTAINS = 93,
        GET_FIELD = 31,
        KEYS = 94,
        VALUES = 186,
        OBJECT = 143,
        HAS_FIELDS = 32,
        WITH_FIELDS = 96,
        PLUCK = 33,
        WITHOUT = 34,
        MERGE = 35,
        BETWEEN_DEPRECATED = 36,
        BETWEEN = 182,
        REDUCE = 37,
        MAP = 38,
        FOLD = 187,
        FILTER = 39,
        CONCAT_MAP = 40,
        ORDER_BY = 41,
        DISTINCT = 42,
        COUNT = 43,
        IS_EMPTY = 86,
        UNION = 44,
        NTH = 45,
        BRACKET = 170,
        INNER_JOIN = 48,
        OUTER_JOIN = 49,
        EQ_JOIN = 50,
        ZIP = 72,
        RANGE = 173,
        INSERT_AT = 82,
        DELETE_AT = 83,
        CHANGE_AT = 84,
        SPLICE_AT = 85,
        COERCE_TO = 51,
        TYPE_OF = 52,
        UPDATE = 53,
        DELETE = 54,
        REPLACE = 55,
        INSERT = 56,
        DB_CREATE = 57,
        DB_DROP = 58,
        DB_LIST = 59,
        TABLE_CREATE = 60,
        TABLE_DROP = 61,
        TABLE_LIST = 62,
        CONFIG = 174,
        STATUS = 175,
        WAIT = 177,
        RECONFIGURE = 176,
        REBALANCE = 179,
        SYNC = 138,
        GRANT = 188,
        INDEX_CREATE = 75,
        INDEX_DROP = 76,
        INDEX_LIST = 77,
        INDEX_STATUS = 139,
        INDEX_WAIT = 140,
        INDEX_RENAME = 156,
        FUNCALL = 64,
        BRANCH = 65,
        OR = 66,
        AND = 67,
        FOR_EACH = 68,
        FUNC = 69,
        ASC = 73,
        DESC = 74,
        INFO = 79,
        MATCH = 97,
        UPCASE = 141,
        DOWNCASE = 142,
        SAMPLE = 81,
        DEFAULT = 92,
        JSON = 98,
        TO_JSON_STRING = 172,
        ISO8601 = 99,
        TO_ISO8601 = 100,
        EPOCH_TIME = 101,
        TO_EPOCH_TIME = 102,
        NOW = 103,
        IN_TIMEZONE = 104,
        DURING = 105,
        DATE = 106,
        TIME_OF_DAY = 126,
        TIMEZONE = 127,
        YEAR = 128,
        MONTH = 129,
        DAY = 130,
        DAY_OF_WEEK = 131,
        DAY_OF_YEAR = 132,
        HOURS = 133,
        MINUTES = 134,
        SECONDS = 135,
        TIME = 136,
        MONDAY = 107,
        TUESDAY = 108,
        WEDNESDAY = 109,
        THURSDAY = 110,
        FRIDAY = 111,
        SATURDAY = 112,
        SUNDAY = 113,
        JANUARY = 114,
        FEBRUARY = 115,
        MARCH = 116,
        APRIL = 117,
        MAY = 118,
        JUNE = 119,
        JULY = 120,
        AUGUST = 121,
        SEPTEMBER = 122,
        OCTOBER = 123,
        NOVEMBER = 124,
        DECEMBER = 125,
        LITERAL = 137,
        GROUP = 144,
        SUM = 145,
        AVG = 146,
        MIN = 147,
        MAX = 148,
        SPLIT = 149,
        UNGROUP = 150,
        RANDOM = 151,
        CHANGES = 152,
        ARGS = 154,
        BINARY = 155,
        GEOJSON = 157,
        TO_GEOJSON = 158,
        POINT = 159,
        LINE = 160,
        POLYGON = 161,
        DISTANCE = 162,
        INTERSECTS = 163,
        INCLUDES = 164,
        CIRCLE = 165,
        GET_INTERSECTING = 166,
        FILL = 167,
        GET_NEAREST = 168,
        POLYGON_SUB = 171,
        MINVAL = 180,
        MAXVAL = 181,
    };
    namespace AssocPair {
    }
}
} }

#include <cstddef>
#include <string>

namespace RethinkDB {

// The size of the longest UTF-8 encoded unicode codepoint
const size_t max_utf8_encoded_size = 6;

// Decode a base64 string. Returns false on failure.
bool base64_decode(const std::string& in, std::string& out);
std::string base64_encode(const std::string&);

// Encodes a single unicode codepoint into UTF-8. Returns the number of bytes written.
// Does not add a trailing null byte
size_t utf8_encode(unsigned int, char*);

}

#include <cstdarg>
#include <cstring>
#include <string>
#include <cerrno>

namespace RethinkDB {

// All errors thrown by the server have this type
struct Error {
    template <class ...T>
    explicit Error(const char* format_, T... A) {
        format(format_, A...);
    }

    Error() = default;
    Error(Error&&) = default;
    Error(const Error&) = default;

    Error& operator= (Error&& other) {
        message = std::move(other.message);
        return *this;
    }

    static Error from_errno(const char* str){
        return Error("%s: %s", str, strerror(errno));
    }

    // The error message
    std::string message;

private:
    const size_t max_message_size = 2048;

    void format(const char* format_, ...) {
        va_list args;
        va_start(args, format_);
        char message_[max_message_size];
        vsnprintf(message_, max_message_size, format_, args);
        va_end(args);
        message = message_;
    }
};

}
#ifndef EXCEPTIONS_H
#define EXCEPTIONS_H

namespace RethinkDB {

class TimeoutException : public std::exception {
public:
    const char *what() const throw () { return "operation timed out"; }
};

}

#endif  // EXCEPTIONS_H

#include <vector>
#include <map>
#include <ctime>
#include <string>

namespace RethinkDB {

class Datum;

// Represents a null datum
struct Nil { };

using Array = std::vector<Datum>;
using Object = std::map<std::string, Datum>;

// Represents a string of bytes. Plain std::strings are passed on to the server as utf-8 strings
struct Binary {
    bool operator== (const Binary& other) const {
        return data == other.data;
    }

    Binary(const std::string& data_) : data(data_) { }
    Binary(std::string&& data_) : data(std::move(data_)) { }
    std::string data;
};

// Represents a point in time as
//  * A floating amount of seconds since the UNIX epoch
//  * And a timezone offset represented as seconds relative to UTC
struct Time {
    Time(double epoch_time_, double utc_offset_ = 0) :
        epoch_time(epoch_time_), utc_offset(utc_offset_) { }

    static Time now() {
        return Time(time(NULL));
    }

    static bool parse_utc_offset(const std::string&, double*);
    static double parse_utc_offset(const std::string&);
    static std::string utc_offset_string(double);

    double epoch_time;
    double utc_offset;
};

// Not implemented
class Point;
class Line;
class Polygon;

}

#include <string>
#include <vector>
#include <map>
#include <functional>


namespace RethinkDB {

class Cursor;

// The type of data stored in a RethinkDB database.
// The following JSON types are represented in a Datum as
//  * null -> Nil
//  * boolean -> bool
//  * number -> double
//  * unicode strings -> std::string
//  * array -> Array (aka std::vector<Datum>
//  * object -> Object (aka std::map<std::string, Datum>>
// Datums can also contain one of the following extra types
//  * binary strings -> Binary
//  * timestamps -> Time
//  * points. lines and polygons -> not implemented
class Datum {
public:
    Datum(Nil) : type(Type::NIL), value() { }
    Datum(bool boolean_) : type(Type::BOOLEAN), value(boolean_) { }
    Datum(double number_) : type(Type::NUMBER), value(number_) { }
    Datum(const std::string& string_) : type(Type::STRING), value(string_) { }
    Datum(std::string&& string_) : type(Type::STRING), value(std::move(string_)) { }
    Datum(const Array& array_) : type(Type::ARRAY), value(array_) { }
    Datum(Array&& array_) : type(Type::ARRAY), value(std::move(array_)) { }
    Datum(const Binary& binary) : type(Type::BINARY), value(binary) { }
    Datum(Binary&& binary) : type(Type::BINARY), value(std::move(binary)) { }
    Datum(const Time time) : type(Type::TIME), value(time) { }
    Datum(const Object& object_) : type(Type::OBJECT), value(object_) { }
    Datum(Object&& object_) : type(Type::OBJECT), value(std::move(object_)) { }
    Datum(const Datum& other) : type(other.type), value(other.type, other.value) { }
    Datum(Datum&& other) : type(other.type), value(other.type, std::move(other.value)) { }

    Datum& operator=(const Datum& other) {
        value.destroy(type);
        type = other.type;
        value.set(type, other.value);
        return *this;
    }

    Datum& operator=(Datum&& other) {
        value.destroy(type);
        type = other.type;
        value.set(type, std::move(other.value));
        return *this;
    }

    Datum(unsigned short number_) : Datum(static_cast<double>(number_)) { }
    Datum(signed short number_) : Datum(static_cast<double>(number_)) { }
    Datum(unsigned int number_) : Datum(static_cast<double>(number_)) { }
    Datum(signed int number_) : Datum(static_cast<double>(number_)) { }
    Datum(unsigned long number_) : Datum(static_cast<double>(number_)) { }
    Datum(signed long number_) : Datum(static_cast<double>(number_)) { }
    Datum(unsigned long long number_) : Datum(static_cast<double>(number_)) { }
    Datum(signed long long number_) : Datum(static_cast<double>(number_)) { }

    Datum(Protocol::Term::TermType type) : Datum(static_cast<double>(type)) { }
    Datum(const char* string) : Datum(static_cast<std::string>(string)) { }

    // Cursors are implicitly converted into datums
    Datum(Cursor&&);
    Datum(const Cursor&);

    template <class T>
    Datum(const std::map<std::string, T>& map) : type(Type::OBJECT), value(Object()) {
        for (const auto& it : map) {
            value.object.emplace(it.left, Datum(it.right));
        }
    }

    template <class T>
    Datum(std::map<std::string, T>&& map) : type(Type::OBJECT), value(Object()) {
        for (auto& it : map) {
            value.object.emplace(it.first, Datum(std::move(it.second)));
        }
    }

    template <class T>
    Datum(const std::vector<T>& vec) : type(Type::ARRAY), value(Array()) {
        for (const auto& it : vec) {
            value.array.emplace_back(it);
        }
    }

    template <class T>
    Datum(std::vector<T>&& vec) : type(Type::ARRAY), value(Array()) {
        for (auto& it : vec) {
            value.array.emplace_back(std::move(it));
        }
    }

    ~Datum() {
        value.destroy(type);
    }

    // Apply a visitor
    template <class R, class F, class ...A>
    R apply(F f, A&& ...args) const & {
        switch (type) {
        case Type::NIL: return f(Nil(), std::forward<A>(args)...); break;
        case Type::BOOLEAN: return f(value.boolean, std::forward<A>(args)...); break;
        case Type::NUMBER: return f(value.number, std::forward<A>(args)...); break;
        case Type::STRING: return f(value.string, std::forward<A>(args)...); break;
        case Type::OBJECT: return f(value.object, std::forward<A>(args)...); break;
        case Type::ARRAY: return f(value.array, std::forward<A>(args)...); break;
        case Type::BINARY: return f(value.binary, std::forward<A>(args)...); break;
        case Type::TIME: return f(value.time, std::forward<A>(args)...); break;
        }
        throw Error("internal error: no such datum type %d", static_cast<int>(type));
    }

    template <class R, class F, class ...A>
    R apply(F f, A&& ...args) && {
        switch (type) {
        case Type::NIL: return f(Nil(), std::forward<A>(args)...); break;
        case Type::BOOLEAN: return f(std::move(value.boolean), std::forward<A>(args)...); break;
        case Type::NUMBER: return f(std::move(value.number), std::forward<A>(args)...); break;
        case Type::STRING: return f(std::move(value.string), std::forward<A>(args)...); break;
        case Type::OBJECT: return f(std::move(value.object), std::forward<A>(args)...); break;
        case Type::ARRAY: return f(std::move(value.array), std::forward<A>(args)...); break;
        case Type::BINARY: return f(std::move(value.binary), std::forward<A>(args)...); break;
        case Type::TIME: return f(std::move(value.time), std::forward<A>(args)...); break;
        }
        throw Error("internal error: no such datum type %d", static_cast<int>(type));
    }

    bool is_nil() const;

    // get_* returns nullptr if the datum has a different type

    bool* get_boolean();
    const bool* get_boolean() const;
    double* get_number();
    const double* get_number() const;
    std::string* get_string();
    const std::string* get_string() const;
    Object* get_object();
    const Object* get_object() const;
    Datum* get_field(std::string);
    const Datum* get_field(std::string) const;
    Array* get_array();
    const Array* get_array() const;
    Datum* get_nth(size_t);
    const Datum* get_nth(size_t) const;
    Binary* get_binary();
    const Binary* get_binary() const;
    Time* get_time();
    const Time* get_time() const;

    // extract_* throws an exception if the types don't match

    bool& extract_boolean();
    double& extract_number();
    std::string& extract_string();
    Object& extract_object();
    Datum& extract_field(std::string);
    Array& extract_array();
    Datum& extract_nth(size_t);
    Binary& extract_binary();
    Time& extract_time();

    // negative, zero or positive if this datum is smaller, identical or larger than the other one, respectively
    // This is meant to match the results of RethinkDB's comparison operators
    int compare(const Datum&) const;

    // Deep equality
    bool operator== (const Datum&) const;

    // Recusively replace non-JSON types into objects that represent them
    Datum to_raw() const;

    // Recursively replace objects with a $reql_type$ field into the datum they represent
    Datum from_raw() const;

    template <class json_writer_t> void write_json(json_writer_t *writer) const;

private:
    enum class Type {
        ARRAY, BOOLEAN, NIL, NUMBER, OBJECT, BINARY, STRING, TIME
        // POINT, LINE, POLYGON
    };
    Type type;

    union datum_value {
        bool boolean;
        double number;
        std::string string;
        Object object;
        Array array;
        Binary binary;
        Time time;

        datum_value() { }
        datum_value(bool boolean_) : boolean(boolean_) { }
        datum_value(double number_) : number(number_) { }
        datum_value(const std::string& string_) : string(string_) { }
        datum_value(std::string&& string_) : string(std::move(string_)) { }
        datum_value(const Object& object_) : object(object_) { }
        datum_value(Object&& object_) : object(std::move(object_)) { }
        datum_value(const Array& array_) : array(array_) { }
        datum_value(Array&& array_) : array(std::move(array_)) { }
        datum_value(const Binary& binary_) : binary(binary_) { }
        datum_value(Binary&& binary_) : binary(std::move(binary_)) { }
        datum_value(Time time) : time(std::move(time)) { }

        datum_value(Type type, const datum_value& other){
            set(type, other);
        }

        datum_value(Type type, datum_value&& other){
            set(type, std::move(other));
        }

        void set(Type type, datum_value&& other) {
            switch(type){
            case Type::NIL: break;
            case Type::BOOLEAN: new (this) bool(other.boolean); break;
            case Type::NUMBER: new (this) double(other.number); break;
            case Type::STRING: new (this) std::string(std::move(other.string)); break;
            case Type::OBJECT: new (this) Object(std::move(other.object)); break;
            case Type::ARRAY: new (this) Array(std::move(other.array)); break;
            case Type::BINARY: new (this) Binary(std::move(other.binary)); break;
            case Type::TIME: new (this) Time(std::move(other.time)); break;
            }
        }

        void set(Type type, const datum_value& other) {
            switch(type){
            case Type::NIL: break;
            case Type::BOOLEAN: new (this) bool(other.boolean); break;
            case Type::NUMBER: new (this) double(other.number); break;
            case Type::STRING: new (this) std::string(other.string); break;
            case Type::OBJECT: new (this) Object(other.object); break;
            case Type::ARRAY: new (this) Array(other.array); break;
            case Type::BINARY: new (this) Binary(other.binary); break;
            case Type::TIME: new (this) Time(other.time); break;
            }
        }

        void destroy(Type type) {
            switch(type){
            case Type::NIL: break;
            case Type::BOOLEAN: break;
            case Type::NUMBER: break;
            case Type::STRING: { typedef std::string str; string.~str(); } break;
            case Type::OBJECT: object.~Object(); break;
            case Type::ARRAY: array.~Array(); break;
            case Type::BINARY: binary.~Binary(); break;
            case Type::TIME: time.~Time(); break;
            }
        }

        ~datum_value() { }
    };

    datum_value value;
};

}


namespace rapidjson {
  class CrtAllocator;
  template<typename> struct UTF8;
  template <typename, typename> class GenericValue;
  template <typename> class MemoryPoolAllocator;
  typedef GenericValue<UTF8<char>, MemoryPoolAllocator<CrtAllocator> > Value;
}

namespace RethinkDB {

Datum read_datum(const std::string&);
Datum read_datum(const rapidjson::Value &json);
std::string write_datum(const Datum&);

}

#include <string>
#include <queue>
#include <mutex>
#include <memory>
#include <condition_variable>


#define FOREVER (-1)
#define SECOND 1
#define MICROSECOND 0.0000001

namespace RethinkDB {

class Token;
class Connection;

// Used internally to convert a raw response type into an enum
Protocol::Response::ResponseType response_type(double t);
Protocol::Response::ErrorType runtime_error_type(double t);

// Contains a response from the server. Use the Cursor class to interact with these responses
class Response {
public:
    Response() = delete;
    explicit Response(Datum&& datum) :
        type(response_type(std::move(datum).extract_field("t").extract_number())),
        error_type(datum.get_field("e") ?
                   runtime_error_type(std::move(datum).extract_field("e").extract_number()) :
                   Protocol::Response::ErrorType(0)),
        result(std::move(datum).extract_field("r").extract_array()) { }
    Error as_error();
    Protocol::Response::ResponseType type;
    Protocol::Response::ErrorType error_type;
    Array result;
};

// A connection to a RethinkDB server
// It contains:
//  * A socket
//  * Read and write locks
//  * A cache of responses that have not been read by the corresponding Cursor
class Connection {
public:
    Connection(const std::string& host, int port, const std::string& auth_key);

    Connection(const Connection&) = delete;
    Connection(Connection&&) = default;

    // Used internally by Term::run
    Token start_query(const std::string&);

    void close();

private:
    Response wait_for_response(uint64_t, double);
    void close_token(uint64_t);
    void ask_for_more(uint64_t);

    friend class SocketReadStream;
    friend class Token;

    const uint32_t version_magic = static_cast<uint32_t>(Protocol::VersionDummy::Version::V0_4);
    const uint32_t json_magic = static_cast<uint32_t>(Protocol::VersionDummy::Protocol::JSON);

    class ReadLock;
    class WriteLock;
    class CacheLock;

    std::mutex read_lock;
    std::mutex write_lock;
    std::mutex cache_lock;

    struct TokenCache {
        bool closed = false;
        std::condition_variable cond;
        std::queue<Response> responses;
    };

    std::map<uint32_t, TokenCache> guarded_cache;
    uint64_t guarded_next_token;
    int guarded_sockfd;
    bool guarded_loop_active;
};

// $doc(connect)
std::unique_ptr<Connection> connect(std::string host = "localhost", int port = 28015, std::string auth_key = "");

// Each server response is associated with a token, which allows multiplexing streams
// A token can be used to create a cursor
class Token {
public:
    Token(Connection::WriteLock&);
    Token() : conn(nullptr), token(0) { }

    Token(const Token&) = delete;
    Token& operator=(const Token&) = delete;

    Token& operator=(Token&& other){
        token = other.token;
        conn = other.conn;
        other.conn = nullptr;
        other.token = 0;
        return *this;
    }

    Token(Token&& other) : conn(other.conn), token(other.token) {
        other.conn = nullptr;
        other.token = 0;
    }

    void ask_for_more() const {
        conn->ask_for_more(token);
    }

    Response wait_for_response(double wait) const {
        return conn->wait_for_response(token, wait);
    }

    void close() const {
        if(conn) {
            conn->close_token(token);
        }
    }

    ~Token() {
        close();
    }
private:
    friend class Connection;
    Connection* conn;
    uint64_t token;
};

}


namespace RethinkDB {

// The response from the server, as returned by run.
// The response is either a single datum or a stream:
//  * If it is a stream, the cursor represents each element of the stream.
//    - Batches are fetched from the server as needed.
//  * If it is a single datum, is_single() returns true.
//    - If it is an array, the cursor represents each element of that array
//    - Otherwise, to_datum() returns the datum and iteration throws an exception.
// The cursor can only be iterated over once, it discards data that has already been read.
class Cursor {
public:
    Cursor() = delete;
    Cursor(Token&&);
    Cursor(Token&&, Datum&&);
    Cursor(Datum&&);
    ~Cursor();

    // movable
    Cursor(Cursor&&) = default;
    Cursor& operator=(Cursor&&) = default;

    // not copyable
    Cursor(const Cursor&) = delete;
    Cursor& operator=(const Cursor&) = delete;

    // Returned by begin() and end()
    class iterator {
    public:
        iterator(Cursor*);
        iterator& operator++ ();
        Datum& operator* ();
        bool operator!= (const iterator&) const;

    private:
        Cursor *cursor;
    };

    // Consume the next element
    Datum& next(double wait = FOREVER) const;

    // Peek at the next element
    Datum& peek(double wait = FOREVER) const;

    // Call f on every element of the Cursor
    void each(std::function<void(Datum&&)> f, double wait = FOREVER) const;

    // Consume and return all elements
    Array&& to_array() &&;

    // If is_single(), returns the single datum. Otherwise returns to_array().
    Datum to_datum() &&;
    Datum to_datum() const &;

    // Efficiently consume and return all elements
    Array to_array() const &;

    // Close the cursor
    void close() const;

    // Returns false if there are no more elements
    bool has_next(double wait = FOREVER) const;

    // Returns false if the cursor is a stream
    bool is_single() const;

    iterator begin();
    iterator end();

private:
    void add_response(Response&&) const;
    void add_results(Array&&) const;
    void clear_and_read_all() const;
    void convert_single() const;

    mutable bool single;
    mutable bool no_more;
    mutable size_t index;
    mutable Array buffer;
    Token token;
};

}


namespace RethinkDB {

using TT = Protocol::Term::TermType;

class Term;
class Var;

// An alias for the Term constructor
template <class T>
Term expr(T&&);

int gen_var_id();

// Can be used as the last argument to some ReQL commands that expect named arguments
using OptArgs = std::map<std::string, Term>;

// Represents a ReQL Term (RethinkDB Query Language)
// Designed to be used with r-value *this
class Term {
public:
    Term(const Term& other) = default;
    Term(Term&& other) = default;
    Term& operator= (const Term& other) = default;
    Term& operator= (Term&& other) = default;

    explicit Term(Datum&&);
    explicit Term(const Datum&);
    explicit Term(OptArgs&&);

    // Create a copy of the Term
    Term copy() const;

    Term(std::function<Term()> f) : datum(Nil()) { set_function<std::function<Term()>>(f); }
    Term(std::function<Term(Var)> f) : datum(Nil()) { set_function<std::function<Term(Var)>, 0>(f); }
    Term(std::function<Term(Var, Var)> f) : datum(Nil()) { set_function<std::function<Term(Var, Var)>, 0, 1>(f); }
    Term(std::function<Term(Var, Var, Var)> f) : datum(Nil()) { set_function<std::function<Term(Var, Var, Var)>, 0, 1, 2>(f); }
    Term(Protocol::Term::TermType type, std::vector<Term>&& args) : datum(Array()) {
        Array dargs;
        for (auto& it : args) {
            dargs.emplace_back(alpha_rename(std::move(it)));
        }
        datum = Datum(Array{ type, std::move(dargs) });
    }

    Term(Protocol::Term::TermType type, std::vector<Term>&& args, OptArgs&& optargs) : datum(Array()) {
        Array dargs;
        for (auto& it : args) {
            dargs.emplace_back(alpha_rename(std::move(it)));
        }
        Object oargs;
        for (auto& it : optargs) {
            oargs.emplace(it.first, alpha_rename(std::move(it.second)));
        }
        datum = Array{ type, std::move(dargs), std::move(oargs) };
    }

    // Used internally to support row
    static Term func_wrap(Term&&);
    static Term func_wrap(const Term&);


    // These macros are used to define most ReQL commands
    //  * Cn represents a method with n arguments
    //  * COn represents a method with n arguments and optional named arguments
    //  * C_ represents a method with any number of arguments
    // Each method is implemented twice, once with r-value *this, and once with const *this
    // The third argument, wrap, allows converting arguments into functions if they contain row

#define C0(name, type) \
    Term name() &&      { return Term(TT::type, std::vector<Term>{ std::move(*this) }); } \
    Term name() const & { return Term(TT::type, std::vector<Term>{ *this            }); }
#define C1(name, type, wrap)                                            \
    template <class T>                                                  \
    Term name(T&& a) && { return Term(TT::type, std::vector<Term>{ std::move(*this), wrap(expr(std::forward<T>(a))) }); } \
    template <class T>                                                  \
    Term name(T&& a) const & { return Term(TT::type, std::vector<Term>{ *this, wrap(expr(std::forward<T>(a))) }); }
#define C2(name, type)                                                  \
    template <class T, class U> Term name(T&& a, U&& b) && {           \
        return Term(TT::type, std::vector<Term>{ std::move(*this),    \
                    expr(std::forward<T>(a)), expr(std::forward<U>(b)) }); } \
    template <class T, class U> Term name(T&& a, U&& b) const & {      \
        return Term(TT::type, std::vector<Term>{ *this,        \
                    expr(std::forward<T>(a)), expr(std::forward<U>(b)) }); }
#define C_(name, type, wrap)                                            \
    template <class ...T> Term name(T&& ...a) && {                     \
        return Term(TT::type, std::vector<Term>{ std::move(*this),    \
                    wrap(expr(std::forward<T>(a)))... }); }             \
    template <class ...T> Term name(T&& ...a) const & {                \
        return Term(TT::type, std::vector<Term>{ *this,        \
                    wrap(expr(std::forward<T>(a)))... }); }
#define CO0(name, type)                                                 \
    Term name(OptArgs&& optarg = {}) && {                              \
        return Term(TT::type, std::vector<Term>{ std::move(*this) }, std::move(optarg)); } \
    Term name(OptArgs&& optarg = {}) const & {                         \
        return Term(TT::type, std::vector<Term>{ *this }, std::move(optarg)); }
#define CO1(name, type, wrap)                                                \
    template <class T> Term name(T&& a, OptArgs&& optarg = {}) && {    \
        return Term(TT::type, std::vector<Term>{ std::move(*this),    \
                    wrap(expr(std::forward<T>(a))) }, std::move(optarg)); } \
    template <class T> Term name(T&& a, OptArgs&& optarg = {}) const & { \
        return Term(TT::type, std::vector<Term>{ *this,               \
                    wrap(expr(std::forward<T>(a))) }, std::move(optarg)); }
#define CO2(name, type, wrap)                                           \
    template <class T, class U> Term name(T&& a, U&& b, OptArgs&& optarg = {}) && { \
        return Term(TT::type, std::vector<Term>{ std::move(*this),    \
                    wrap(expr(std::forward<T>(a))), wrap(expr(std::forward<U>(b))) }, std::move(optarg)); } \
    template <class T, class U> Term name(T&& a, U&& b, OptArgs&& optarg = {}) const & { \
        return Term(TT::type, std::vector<Term>{ *this,        \
                    wrap(expr(std::forward<T>(a))), wrap(expr(std::forward<U>(b))) }, std::move(optarg)); }
#define CO3(name, type, wrap)                                                \
    template <class T, class U, class V> Term name(T&& a, U&& b, V&& c, OptArgs&& optarg = {}) && { \
        return Term(TT::type, std::vector<Term>{ std::move(*this),    \
                    wrap(expr(std::forward<T>(a))), wrap(expr(std::forward<U>(b))), \
                    wrap(expr(std::forward<V>(c))) }, std::move(optarg)); } \
    template <class T, class U, class V> Term name(T&& a, U&& b, V&& c, OptArgs&& optarg = {}) const & { \
        return Term(TT::type, std::vector<Term>{ *this,        \
                    wrap(expr(std::forward<T>(a))), wrap(expr(std::forward<U>(b))), \
                    wrap(expr(std::forward<V>(c)))}, std::move(optarg)); }
#define CO4(name, type, wrap)                                                \
    template <class T, class U, class V, class W> Term name(T&& a, U&& b, V&& c, W&& d, OptArgs&& optarg = {}) && { \
        return Term(TT::type, std::vector<Term>{ std::move(*this),    \
        wrap(expr(std::forward<T>(a))), wrap(expr(std::forward<U>(b))), \
        wrap(expr(std::forward<V>(c))), wrap(expr(std::forward<W>(d))) }, std::move(optarg)); } \
    template <class T, class U, class V, class W> Term name(T&& a, U&& b, V&& c, W&& d, OptArgs&& optarg = {}) const & { \
        return Term(TT::type, std::vector<Term>{ *this,        \
        wrap(expr(std::forward<T>(a))), wrap(expr(std::forward<U>(b))), \
        wrap(expr(std::forward<V>(c))), wrap(expr(std::forward<W>(d))) }, std::move(optarg)); }
#define CO_(name, type, wrap)                                       \
    C_(name, type, wrap)                                            \
    CO0(name, type)                                                 \
    CO1(name, type, wrap)                                           \
    CO2(name, type, wrap)                                           \
    CO3(name, type, wrap)                                           \
    CO4(name, type, wrap)
#define no_wrap(x) x

    CO1(table_create, TABLE_CREATE, no_wrap)
    C1(table_drop, TABLE_DROP, no_wrap)
    C0(table_list, TABLE_LIST)
    CO1(index_create, INDEX_CREATE, no_wrap)
    CO2(index_create, INDEX_CREATE, func_wrap)
    C1(index_drop, INDEX_DROP, no_wrap)
    C0(index_list, INDEX_LIST)
    CO2(index_rename, INDEX_RENAME, no_wrap)
    C_(index_status, INDEX_STATUS, no_wrap)
    C_(index_wait, INDEX_WAIT, no_wrap)
    CO0(changes, CHANGES)
    CO1(insert, INSERT, no_wrap)
    CO1(update, UPDATE, func_wrap)
    CO1(replace, REPLACE, func_wrap)
    CO0(delete_, DELETE)
    C0(sync, SYNC)
    CO1(table, TABLE, no_wrap)
    C1(get, GET, no_wrap)
    CO_(get_all, GET_ALL, no_wrap)
    CO2(between, BETWEEN, no_wrap)
    CO1(filter, FILTER, func_wrap)
    C2(inner_join, INNER_JOIN)
    C2(outer_join, OUTER_JOIN)
    CO2(eq_join, EQ_JOIN, func_wrap)
    C0(zip, ZIP)
    C_(map, MAP, func_wrap)
    C_(with_fields, WITH_FIELDS, no_wrap)
    C1(concat_map, CONCAT_MAP, func_wrap)
    CO_(order_by, ORDER_BY, func_wrap)
    C1(skip, SKIP, no_wrap)
    C1(limit, LIMIT, no_wrap)
    CO1(slice, SLICE, no_wrap)
    CO2(slice, SLICE, no_wrap)
    C1(nth, NTH, no_wrap)
    C1(offsets_of, OFFSETS_OF, func_wrap)
    C0(is_empty, IS_EMPTY)
    CO_(union_, UNION, no_wrap)
    C1(sample, SAMPLE, no_wrap)
    CO_(group, GROUP, func_wrap)
    C0(ungroup, UNGROUP)
    C1(reduce, REDUCE, no_wrap)
    CO2(fold, FOLD, no_wrap)
    C0(count, COUNT)
    C1(count, COUNT, func_wrap)
    C0(sum, SUM)
    C1(sum, SUM, func_wrap)
    C0(avg, AVG)
    C1(avg, AVG, func_wrap)
    C1(min, MIN, func_wrap)
    CO0(min, MIN)
    C1(max, MAX, func_wrap)
    CO0(max, MAX)
    CO0(distinct, DISTINCT)
    C_(contains, CONTAINS, func_wrap)
    C_(pluck, PLUCK, no_wrap)
    C_(without, WITHOUT, no_wrap)
    C_(merge, MERGE, func_wrap)
    C1(append, APPEND, no_wrap)
    C1(prepend, PREPEND, no_wrap)
    C1(difference, DIFFERENCE, no_wrap)
    C1(set_insert, SET_INSERT, no_wrap)
    C1(set_union, SET_UNION, no_wrap)
    C1(set_intersection, SET_INTERSECTION, no_wrap)
    C1(set_difference, SET_DIFFERENCE, no_wrap)
    C1(operator[], BRACKET, no_wrap)
    C1(get_field, GET_FIELD, no_wrap)
    C_(has_fields, HAS_FIELDS, no_wrap)
    C2(insert_at, INSERT_AT)
    C2(splice_at, SPLICE_AT)
    C1(delete_at, DELETE_AT, no_wrap)
    C2(delete_at, DELETE_AT)
    C2(change_at, CHANGE_AT)
    C0(keys, KEYS)
    C1(match, MATCH, no_wrap)
    C0(split, SPLIT)
    C1(split, SPLIT, no_wrap)
    C2(split, SPLIT)
    C0(upcase, UPCASE)
    C0(downcase, DOWNCASE)
    C_(add, ADD, no_wrap)
    C1(operator+, ADD, no_wrap)
    C_(sub, SUB, no_wrap)
    C1(operator-, SUB, no_wrap)
    C_(mul, MUL, no_wrap)
    C1(operator*, MUL, no_wrap)
    C_(div, DIV, no_wrap)
    C1(operator/, DIV, no_wrap)
    C1(mod, MOD, no_wrap)
    C1(operator%, MOD, no_wrap)
    C_(and_, AND, no_wrap)
    C1(operator&&, AND, no_wrap)
    C_(or_, OR, no_wrap)
    C1(operator||, OR, no_wrap)
    C1(eq, EQ, no_wrap)
    C1(operator==, EQ, no_wrap)
    C1(ne, NE, no_wrap)
    C1(operator!=, NE, no_wrap)
    C1(gt, GT, no_wrap)
    C1(operator>, GT, no_wrap)
    C1(ge, GE, no_wrap)
    C1(operator>=, GE, no_wrap)
    C1(lt, LT, no_wrap)
    C1(operator<, LT, no_wrap)
    C1(le, LE, no_wrap)
    C1(operator<=, LE, no_wrap)
    C0(not_, NOT)
    C0(operator!, NOT)
    C1(in_timezone, IN_TIMEZONE, no_wrap)
    C0(timezone, TIMEZONE)
    CO2(during, DURING, no_wrap)
    C0(date, DATE)
    C0(time_of_day, TIME_OF_DAY)
    C0(year, YEAR)
    C0(month, MONTH)
    C0(day, DAY)
    C0(day_of_week, DAY_OF_WEEK)
    C0(day_of_year, DAY_OF_YEAR)
    C0(hours, HOURS)
    C0(minutes, MINUTES)
    C0(seconds, SECONDS)
    C0(to_iso8601, TO_ISO8601)
    C0(to_epoch_time, TO_EPOCH_TIME)
    C1(for_each, FOR_EACH, func_wrap)
    C1(default_, DEFAULT, no_wrap)
    CO1(js, JAVASCRIPT, no_wrap)
    C1(coerce_to, COERCE_TO, no_wrap)
    C0(type_of, TYPE_OF)
    C0(info, INFO)
    C0(to_json, TO_JSON_STRING)
    C0(to_json_string, TO_JSON_STRING)
    C1(distance, DISTANCE, no_wrap)
    C0(fill, FILL)
    C0(to_geojson, TO_GEOJSON)
    CO1(get_intersecting, GET_INTERSECTING, no_wrap)
    CO1(get_nearest, GET_NEAREST, no_wrap)
    C1(includes, INCLUDES, no_wrap)
    C1(intersects, INTERSECTS, no_wrap)
    C1(polygon_sub, POLYGON_SUB, no_wrap)
    C0(config, CONFIG)
    C0(rebalance, REBALANCE)
    CO0(reconfigure, RECONFIGURE)
    C0(status, STATUS)
    CO0(wait, WAIT)
    C0(floor, FLOOR)
    C0(ceil, CEIL)
    C0(round, ROUND)
    C0(values, VALUES)

    // The expansion of this macro fails to compile on some versions of GCC and Clang:
    // C_(operator(), FUNCALL, no_wrap)
    // The std::enable_if makes the error go away

    // $doc(do)

    template <class T, class ...U>
    typename std::enable_if<!std::is_same<T, Var>::value, Term>::type
    operator() (T&& a, U&& ...b) && {
        return Term(TT::FUNCALL, std::vector<Term>{
                std::move(*this),
                expr(std::forward<T>(a)),
                expr(std::forward<U>(b))... });
    }
    template <class T, class ...U>
    typename std::enable_if<!std::is_same<T, Var>::value, Term>::type
    operator() (T&& a, U&& ...b) const & {
        return Term(TT::FUNCALL, std::vector<Term>{
                *this,
                expr(std::forward<T>(a)),
                expr(std::forward<U>(b))... });
    }

#undef C0
#undef C1
#undef C2
#undef C_
#undef CO0
#undef CO1
#undef CO2

    // Send the term to the server and return the results.
    // Errors returned by the server are thrown.
    Cursor run(Connection&, OptArgs&& args = {});

    // $doc(do)
    template <class ...T>
    Term do_(T&& ...a) && {
        auto list = { std::move(*this), Term::func_wrap(expr(std::forward<T>(a)))... };
        std::vector<Term> args;
        args.reserve(list.size() + 1);
        args.emplace_back(func_wrap(std::move(*(list.end()-1))));
        for (auto it = list.begin(); it + 1 != list.end(); ++it) {
            args.emplace_back(std::move(*it));
        }
        return Term(TT::FUNCALL, std::move(args));
    }

    // Adds optargs to an already built term
    Term opt(OptArgs&& optargs) && {
        return Term(std::move(*this), std::move(optargs));
    }

    // Used internally to implement object()
    static Term make_object(std::vector<Term>&&);

    // Used internally to implement array()
    static Term make_binary(Term&&);

    Datum get_datum() const;

private:
    friend class Var;

    template <int _>
    Var mkvar(std::vector<int>& vars);

    template <class F, int ...N>
    void set_function(F);

    Datum alpha_rename(Term&&);

    Term(Term&& orig, OptArgs&& optargs);

    std::map<int, int*> free_vars;
    Datum datum;
};

// A term representing null
Term nil();

template <class T>
Term expr(T&& a) {
    return Term(std::forward<T>(a));
}

// Represents a ReQL variable.
// This type is passed to functions used in ReQL queries.
class Var {
public:
    // Convert to a term
    Term operator*() const {
        Term term(TT::VAR, std::vector<Term>{expr(*id)});
        term.free_vars = {{*id, id}};
        return term;
    }

    Var(int* id_) : id(id_) { }
private:
    int* id;
};

template <int N>
Var Term::mkvar(std::vector<int>& vars) {
    int id = gen_var_id();
    vars.push_back(id);
    return Var(&*vars.rbegin());
}

template <class F, int ...N>
void Term::set_function(F f) {
    std::vector<int> vars;
    vars.reserve(sizeof...(N));
    std::vector<Var> args = { mkvar<N>(vars)... };
    Term body = f(args[N] ...);

    int* low = &*vars.begin();
    int* high = &*(vars.end() - 1);
    for (auto it = body.free_vars.begin(); it != body.free_vars.end(); ) {
        if (it->second >= low && it->second <= high) {
            if (it->first != *it->second) {
                throw Error("Internal error: variable index mis-match");
            }
            ++it;
        } else {
            free_vars.emplace(*it);
            ++it;
        }
    }
    datum = Array{TT::FUNC, Array{Array{TT::MAKE_ARRAY, vars}, body.datum}};
}

// These macros are similar to those defined above, but for top-level ReQL operations

#define C0(name) Term name();
#define C0_IMPL(name, type) Term name() { return Term(TT::type, std::vector<Term>{}); }
#define CO0(name) Term name(OptArgs&& optargs = {});
#define CO0_IMPL(name, type) Term name(OptArgs&& optargs) { return Term(TT::type, std::vector<Term>{}, std::move(optargs)); }
#define C1(name, type, wrap) template <class T> Term name(T&& a) {          \
        return Term(TT::type, std::vector<Term>{ wrap(expr(std::forward<T>(a))) }); }
#define C2(name, type) template <class T, class U> Term name(T&& a, U&& b) { \
        return Term(TT::type, std::vector<Term>{ expr(std::forward<T>(a)), expr(std::forward<U>(b)) }); }
#define C3(name, type) template <class A, class B, class C>    \
    Term name(A&& a, B&& b, C&& c) { return Term(TT::type, std::vector<Term>{ \
                expr(std::forward<A>(a)), expr(std::forward<B>(b)), expr(std::forward<C>(c)) }); }
#define C4(name, type) template <class A, class B, class C, class D>    \
    Term name(A&& a, B&& b, C&& c, D&& d) { return Term(TT::type, std::vector<Term>{ \
                expr(std::forward<A>(a)), expr(std::forward<B>(b)),     \
                    expr(std::forward<C>(c)), expr(std::forward<D>(d))}); }
#define C7(name, type) template <class A, class B, class C, class D, class E, class F, class G> \
    Term name(A&& a, B&& b, C&& c, D&& d, E&& e, F&& f, G&& g) { return Term(TT::type, std::vector<Term>{ \
        expr(std::forward<A>(a)), expr(std::forward<B>(b)), expr(std::forward<C>(c)), \
        expr(std::forward<D>(d)), expr(std::forward<E>(e)), expr(std::forward<F>(f)), \
            expr(std::forward<G>(g))}); }
#define C_(name, type, wrap) template <class ...T> Term name(T&& ...a) {    \
        return Term(TT::type, std::vector<Term>{ wrap(expr(std::forward<T>(a)))... }); }
#define CO1(name, type, wrap) template <class T> Term name(T&& a, OptArgs&& optarg = {}) {       \
        return Term(TT::type, std::vector<Term>{ wrap(expr(std::forward<T>(a)))}, std::move(optarg)); }
#define CO2(name, type) template <class T, class U> Term name(T&& a, U&& b, OptArgs&& optarg = {}) { \
        return Term(TT::type, std::vector<Term>{ expr(std::forward<T>(a)), expr(std::forward<U>(b))}, std::move(optarg)); }
#define func_wrap Term::func_wrap

C1(db_create, DB_CREATE, no_wrap)
C1(db_drop, DB_DROP, no_wrap)
C0(db_list)
CO1(table_create, TABLE_CREATE, no_wrap)
C1(table_drop, TABLE_DROP, no_wrap)
C0(table_list)
C1(db, DB, no_wrap)
CO1(table, TABLE, no_wrap)
C_(add, ADD, no_wrap)
C2(sub, SUB)
C_(mul, MUL, no_wrap)
C_(div, DIV, no_wrap)
C2(mod, MOD)
C_(and_, AND, no_wrap)
C_(or_, OR, no_wrap)
C2(eq, EQ)
C2(ne, NE)
C2(gt, GT)
C2(ge, GE)
C2(lt, LT)
C2(le, LE)
C1(not_, NOT, no_wrap)
CO0(random)
CO1(random, RANDOM, no_wrap)
CO2(random, RANDOM)
C0(now)
C4(time, TIME)
C7(time, TIME)
C1(epoch_time, EPOCH_TIME, no_wrap)
CO1(iso8601, ISO8601, no_wrap)
CO1(js, JAVASCRIPT, no_wrap)
C1(args, ARGS, no_wrap)
C_(branch, BRANCH, no_wrap)
C0(range)
C1(range, RANGE, no_wrap)
C2(range, RANGE)
C0(error)
C1(error, ERROR, no_wrap)
C1(json, JSON, no_wrap)
CO1(http, HTTP, func_wrap)
C0(uuid)
C1(uuid, UUID, no_wrap)
CO2(circle, CIRCLE)
C1(geojson, GEOJSON, no_wrap)
C_(line, LINE, no_wrap)
C2(point, POINT)
C_(polygon, POLYGON, no_wrap)
C_(array, MAKE_ARRAY, no_wrap)
C1(desc, DESC, func_wrap)
C1(asc, ASC, func_wrap)
C0(literal)
C1(literal, LITERAL, no_wrap)
C1(type_of, TYPE_OF, no_wrap)
C_(map, MAP, func_wrap)
C1(floor, FLOOR, no_wrap)
C1(ceil, CEIL, no_wrap)
C1(round, ROUND, no_wrap)
C_(union_, UNION, no_wrap)
C_(group, GROUP, func_wrap)
C1(count, COUNT, no_wrap)
C_(count, COUNT, func_wrap)
C1(sum, SUM, no_wrap)
C_(sum, SUM, func_wrap)
C1(avg, AVG, no_wrap)
C_(avg, AVG, func_wrap)
C1(min, MIN, no_wrap)
C_(min, MIN, func_wrap)
C1(max, MAX, no_wrap)
C_(max, MAX, func_wrap)
C1(distinct, DISTINCT, no_wrap)
C1(contains, CONTAINS, no_wrap)
C_(contains, CONTAINS, func_wrap)

#undef C0
#undef C1
#undef C2
#undef C3
#undef C4
#undef C7
#undef C_
#undef CO1
#undef CO2
#undef func_wrap

// $doc(do)
template <class R, class ...T>
Term do_(R&& a, T&& ...b) {
    return expr(std::forward<R>(a)).do_(std::forward<T>(b)...);
}

// $doc(object)
template <class ...T>
Term object(T&& ...a) {
    return Term::make_object(std::vector<Term>{ expr(std::forward<T>(a))... });
}

// $doc(binary)
template <class T>
Term binary(T&& a) {
    return Term::make_binary(expr(std::forward<T>(a)));
}

// Construct an empty optarg
OptArgs optargs();

// Construct an optarg made out of pairs of arguments
// For example: optargs("k1", v1, "k2", v2)
template <class V, class ...T>
OptArgs optargs(const char* key, V&& val, T&& ...rest) {
    OptArgs opts = optargs(rest...);
    opts.emplace(key, expr(std::forward<V>(val)));
    return opts;
}

extern Term row;
extern Term maxval;
extern Term minval;
extern Term january;
extern Term february;
extern Term march;
extern Term april;
extern Term may;
extern Term june;
extern Term july;
extern Term august;
extern Term september;
extern Term october;
extern Term november;
extern Term december;
extern Term monday;
extern Term tuesday;
extern Term wednesday;
extern Term thursday;
extern Term friday;
extern Term saturday;
extern Term sunday;
}
